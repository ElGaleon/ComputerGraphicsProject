<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html" class="scroll-smooth" lang="it-IT">
<head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />

    <title>Documentation</title>

    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="../project/css/style.css">
    <link rel="stylesheet" type="text/css" href="../project/css/output.css">
    <link rel="stylesheet" type="text/css" href="./style/style.css">
    <script src="https://unpkg.com/@tailwindcss/browser@4"></script>
</head>

<body class="bg-gray-50 py-8 px-16 flex flex-col gap-4 items-center">
<header class="text-2xl flex flex-col justify-center items-center text-gray-800">
    <h1 class="font-extrabold text-center text-gray-800">Documentazione progetto di Fondamenti di Computer Graphics M - Modulo 1</h1>
    <h3 class="text-xl text-gray-600">Christian Galeone</h3>
    <h5 class="text-lg text-gray-600">A.A. 2024-2025</h5>
</header>

<hr class="my-12 h-0.5 border-t-0 bg-neutral-100" />

<div class="w-full bg-gray-100 px-4 py-3 text-left text-gray-800 break-words max-w-md rounded">
    <div class="mx-auto text-xl font-semibold"><strong>Indice</strong></div>
    <ul class="mt-2 list-disc px-2 pl-6">
        <li>
            <a class="block hover:bg-gray-200 px-2 py-1 rounded" href="#introduzione">Introduzione</a>
        </li>
        <li>
            <a class="block hover:bg-gray-200 px-2 py-1 rounded" href="#architettura">Architettura</a>
        </li>
        <li>
            <a class="block hover:bg-gray-200 px-2 py-1 rounded" href="#interfaccia">Interfaccia</a>
        </li>
        <li>
            <a class="block hover:bg-gray-200 px-2 py-1 rounded" href="#scena1">Scena #1</a>
        </li>
        <li>
            <a class="block hover:bg-gray-200 px-2 py-1 rounded" href="#scena2">Scena #2</a>
        </li>
        <li>
            <a class="block hover:bg-gray-200 px-2 py-1 rounded" href="#scena3">Scena #3</a>
        </li>
        <li>
            <a class="block hover:bg-gray-200 px-2 py-1 rounded" href="#controllo-scena">Controllo scena</a>
        </li>
        <li>
            <a class="block hover:bg-gray-200 px-2 py-1 rounded" href="#best-practices">Luci e Ombre</a>
        </li>
        <li>
            <a class="block hover:bg-gray-200 px-2 py-1 rounded" href="#code-samples">MeshObj</a>
        </li>
        <li>
            <a class="block hover:bg-gray-200 px-2 py-1 rounded" href="#conclusion">Conclusion</a>
        </li>
        <li>
            <a class="block hover:bg-gray-200 px-2 py-1 rounded" href="#change-theme-color">Changing Theme Color in
                Bootstrap</a>
        </li>
        <li>
            <a class="block hover:bg-gray-200 px-2 py-1 rounded" href="#using-theme-color">Using Theme Color in
                Bootstrap</a>
        </li>
        <li>
            <a class="block hover:bg-gray-200 px-2 py-1 rounded" href="#number-of-colors">Number of Colors in
                Bootstrap</a>
        </li>
        <li>
            <a class="block hover:bg-gray-200 px-2 py-1 rounded" href="#customize-theme">Customizing a Bootstrap
                Theme</a>
        </li>
    </ul>
</div>

<h1 id="indice">Indice</h1>
<ul>
    <li><a href="#introduzione">Introduzione</a></li>
    <li><a href="#scene.js">Scene</a></li>
    <li><a href="#camera.js">Camera</a></li>
    <li><a href="#mesh_obj.js">MeshObj</a></li>
    <li><a href="#riferimenti">Riferimenti</a></li>
</ul>
<hr />

<!-- Introduzione -->
<section id="introduzione">
<h1 class="text-xl font-semibold text-gray-800">Introduzione</h1>
<p> Il progetto 'Super Mario 64 in WebGL' è stato realizzato come prova finale del corso "Fondamenti di Computer Graphics M".
    L'obiettivo del progetto è quello di sviluppare un'applicazione web interattiva con scena tridimensionale, utilizzando la libreria grafica WebGL, Javascript e il linguaggio di shading OpenGL ES SL.
    Per scoprire tutti i requisiti del progetto, visitare <a href="../README.md" target="_blank">README.md</a>
</p>

<p>
    Il risultato del progetto è una simulazione di tre scene iconiche del videogioco <a href="https://it.wikipedia.org/wiki/Super_Mario_64">Super Mario 64</a>.<br>
</p>
    <img src="./resources/images/SM64.png" alt="Super Mario 64" class="w-2/5 block ml-auto mr-auto py-2">
</section>
<hr class="my-12 h-0.5 border-t-0 bg-neutral-100" />
<!-- Architettura -->
<section id="architettura">
    <h1 class="text-xl font-semibold text-gray-800">Architettura</h1>
    L'architettura del progetto parte da un template HTML di Intellij IDEA, ed è stato strutturato in directories nel seguente modo:
<ul class="list-disc mb-4">
    <li><code class="text-red-600 bg-gray-200 rounded-md p-1">assets</code>
                directory che contiene tutte le immagini, i font, gli audio, i file json e i file obj necessari alla realizzazione della scena.
        <div class=" my-2 mx-2 bg-teal-100 border-t-4 border-teal-500 rounded-b text-teal-900 px-4 py-3 shadow-md" role="alert">
            <div class="flex">
                <div class="py-1"><svg class="fill-current h-6 w-6 text-teal-500 mr-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0 4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z"/></svg></div>
                <div>
                    <p class="font-bold">File JSON</p>
                    <p class="text-sm">I file JSON sono stati utilizzati come file di configurazione per caricare la scena. Essi contengono tutto i dati necessari per rappresentare gli elementi della scena.</p>
                </div>
            </div>
        </div>
    </li>
    <li><code class="text-red-600 bg-gray-200 rounded-md p-1">css</code>
                contiene i fogli di stile. Per conoscenze e comodità è stato utilizzato il framework TailwindCSS, che ha velocizzato il processo di realizzazione dello stile del sito.
    </li>
    <li><code class="text-red-600 bg-gray-200 rounded-md p-1">lib</code>
                contiene i file di libreria, ovvero tutte le funzioni utili create dall'autore (considerati <i>interni</i>).
    </li>
    <li><code class="text-red-600 bg-gray-200 rounded-md p-1">resources</code>
                contiene le risorse <i>esterne</i> fornite dal professore per la realizzazione del progetto.
    </li>
    <li><code class="text-red-600 bg-gray-200 rounded-md p-1">src</code>
                cartella sorgente che contiene la logica dell'applicazione.
    </li>
</ul>

<p>Di seguito viene mostrata la struttura della directory <code class="text-red-600 bg-gray-200 rounded-md p-1">src</code></p>
    <img src="./resources/images/src.png" alt="src directory" class="w-1/5 block ml-auto mr-auto py-2">

    <p>Per la realizzazione del progetto è stato seguito il principio di separazione previsto dal clean code, in questo modo ogni classe esegue soltanto ciò che è di sua competenza.</p>
    <p>La classe scene agisce come <b>orchestratore</b>: le classi vengono inizializzate e utilizzate al suo interno.</p>
    Breve spiegazione di cosa si occupa ogni file in breve:
    <ul class="list-disc">
        <li><code class="text-red-600 bg-gray-200 rounded-md p-1">Controller2d</code> creazione del controller che simula un controller N64 con canvas 2D </li>
        <li><code class="text-red-600 bg-gray-200 rounded-md p-1">KeyController</code> gestisce la interazioni utente via tastiera </li>
        <li><code class="text-red-600 bg-gray-200 rounded-md p-1">MouseController</code> gestisce la interazioni utente via mouse </li>
        <li><code class="text-red-600 bg-gray-200 rounded-md p-1">TouchController</code> gestisce la interazioni touch dell'utente </li>
        <li><code class="text-red-600 bg-gray-200 rounded-md p-1">App</code> si occupa di caricare la scena e di gestire il cambio di contesto</li>
        <li><code class="text-red-600 bg-gray-200 rounded-md p-1">Camera</code> gestisce la camera della scena</li>
        <li><code class="text-red-600 bg-gray-200 rounded-md p-1">GUI</code> gestisce l'interfaccia dei controlli basandosi sulla libreria <code class="text-red-600 bg-gray-200 rounded-md p-1">dat_gui.js</code></li>
        <li><code class="text-red-600 bg-gray-200 rounded-md p-1">Light</code> gestisce le luci della scena</li>
        <li><code class="text-red-600 bg-gray-200 rounded-md p-1">MeshObj</code> si occupa del caricamento e della gestione degli model 3D </li>
        <li><code class="text-red-600 bg-gray-200 rounded-md p-1">Render</code> si occupa di fare il render della scena</li>
        <li><code class="text-red-600 bg-gray-200 rounded-md p-1">Scene</code> orchestratore e punto nevralgico dell'applicazione</li>
        <li><code class="text-red-600 bg-gray-200 rounded-md p-1">Shadow</code> gestisce le ombre della scena</li>
        <li><code class="text-red-600 bg-gray-200 rounded-md p-1">Skybox</code> gestisce le skybox della scena (se presenti)</li>
    </ul>
</section>
<hr class="my-12 h-0.5 border-t-0 bg-neutral-100" />
<!-- Interfaccia -->
<section id="interfaccia">
    <h1 class="text-xl font-semibold text-gray-800">Interfaccia</h1>
    <div class="flex flex-row justify-center items-center gap-2">
        <img src="./resources/images/interfaccia.png" title="Interfaccia mobile applicazione" alt="Interfaccia mobile applicazione" class="w-3/5 block ml-auto mr-auto py-2">
        <img src="./resources/images/interfaccia_mobile.png" title="Interfaccia mobile applicazione" alt="Interfaccia mobile applicazione" class="w-1/5 block ml-auto mr-auto py-2">
    </div>
<p>
    L'interfaccia dell'applicazione è stata fatta a tema Super Mario 64: ho voluto realizzare qualcosa che richiamasse in tutto e per tutto il gioco,
    per cui ho importato il font del gioco e cercato di sfruttarne anche i colori. Inoltre, l'interfaccia si presenta come una griglia in cui alla sinistra abbiamo
    il nostro canvas dove vengono mostrate le scene, e vi è possibilità di selezionare tra tre scene iconiche del gioco; alla destra - o in basso su smartphone - invece,
    c'è la sezione dedicata ai comandi: nella parte superiore potete trovare una tastiera touch che simula i bottoni fisici o, se preferite, si può cambiare
    e passare al <b>controller N64</b>! <br/>
    Per migliorare l'esperienza utente, ho inserito anche delle immagini che richiamino l'interfaccia del gioco (vedi parte superiore della scena) e ho
    inserito le canzoni di ogni scena, che si caricano ogni volta che se ne seleziona una. In questo modo l'esperienza diventa del tutto immersiva!
</p>
</section>
<hr class="my-12 h-0.5 border-t-0 bg-neutral-100" />
<!-- Scena 1 -->
<section id="scena1">
    <h1 class="text-xl font-semibold text-gray-800">Scena 1 (Bomb-Omb Battlefield)</h1>
    Per soddisfare il requisito di inserire una immagine texture con la mia foto, ho pensato di riprodurre la stanza del primo livello, chiamato "Bomb-Omb Battlefield"
    La stanza è molto semplice, e si presenta con un immenso quadro del livello con un palco sotto. In aggiunta, ho voluto inserire anche l'iconica stella del gioco, che in realtà non compare nella scena.
    <div class="flex flex-row justify-center items-center gap-2">
        <img src="./resources/images/bomb.png" alt="Bomb-Omb" class="w-3/5 block ml-auto mr-auto py-2">
        <img src="./resources/images/bomb-ref.png" alt="Bomb-Omb Ref" class="w-2/5 block ml-auto mr-auto py-2">
    </div>
</section>
<hr class="my-12 h-0.5 border-t-0 bg-neutral-100" />
<!-- Scena 2 -->
<section id="scena2">
    <h1 class="text-xl font-semibold text-gray-800">Scena 2 (Peach Castle)</h1>
    Questa scena è stata quello che ha fatto iniziare tutto, il mio punto di ispirazione. Essendo una costruzione un po' più complessa, ho cercato
    di semplificarla il più possibile, ma questo comunque mi ha portato alcuni problemi: sebbene se su Blender i modelli non avessero distorsioni,
    su Web, invece, sono venuti fuori alcuni effetti che sono un po' fastidiosi. <br/>
    In ogni caso ho deciso di tenere anche questa scena per mostrare il frutto del mio lavoro.
    <div class="flex flex-row justify-center items-center gap-2">
        <img src="./resources/images/castle.png" alt="Castle" class="w-1/2 block ml-auto mr-auto py-2">
        <img src="./resources/images/castle-ref.jpeg" alt="Castle-Ref" class="w-1/2 block ml-auto mr-auto py-2">
    </div>
</section>
<hr class="my-12 h-0.5 border-t-0 bg-neutral-100" />
<!-- Scena 3 -->
<section id="scena3">
    <h1 class="text-xl font-semibold text-gray-800">Scena 3 (Bowser In the Sky)</h1>
    Proprio come nel gioco, questa rappresenta l'ultima scena prima del boss finale: una volta entrato in quel tubo,
    per salvare Peach, Mario dovrà sfidare il suo acerrimo nemico Bowser. Per questo motivo, ho voluto inserire anche questa scena,
    in cui ho potuto sperimentare l'utilizzo delle <b>skybox</b>. Ho cercato di utilizzare l'immagine originale, che non ha
    una qualità elevata: per questo motivo, l'effetto può risultare un po' nauseante.
    Per essere fedeli al gioco, all'interno della scena sono stati inseriti un cuore che ruota (a cui è stata applicata la trasparenza) e la moneta rossa.
    <div class="flex flex-row justify-center items-center gap-2">
        <img src="./resources/images/bowser.png" alt="Castle" class="w-1/2 block ml-auto mr-auto py-2">
        <img src="./resources/images/bowser-ref.png" alt="Castle-Ref" class="w-1/2 block ml-auto mr-auto py-2">
    </div>
    <div class="flex flex-row justify-center items-center gap-2">
        <img src="./resources/images/bowser-coin.png" alt="Bowser coin" class="w-1/2 block ml-auto mr-auto py-2">
        <img src="./resources/images/bowser-coin-ref.webp" alt=" bowser coin Ref" class="w-1/2 block ml-auto mr-auto py-2">
    </div>
    <div class="flex flex-row justify-center items-center gap-2">
        <img src="./resources/images/bowser-heart.png" alt="Bowser heart" class="w-1/2 block ml-auto mr-auto py-2">
        <img src="./resources/images/bowser-heart-ref.png" alt="Bowser heart ref" class="w-1/2 block ml-auto mr-auto py-2">
    </div>
</section>
<hr class="my-12 h-0.5 border-t-0 bg-neutral-100" />
<!-- Controllo scena -->
<section id="controllo-scena">
    <h1 class="text-xl font-semibold text-gray-800">Controllo Scena</h1>
    Per il controllo delle impostazioni della scena, è stata utilizzata la libreria <a href="https://github.com/dataarts/dat.gui">dat.GUI</a>.
    Grazie a questa è possibile gestire le impostazioni della camera, l'attivazione/disattivazione delle ombre e la gestione delle luci.<br/>

    Riguardo l'interazione con l'utente, quest'ultimo può muoversi nella scena in tre modi diversi:
    <ul class="list-disc ml-8">
        <li>Utilizzando la tastiera fisica</li>
        <li>Utilizzando il mouse</li>
        <li>Tramite Tocco
            <ul class="list-disc ml-16">
                <li>Movimento del dito</li>
                <li>Interfaccia Tastiera </li>
                <li>Interfaccia Gamepad</li>
            </ul>
        </li>
    </ul>
    I tasti per controllare il movimento la direzione di vista sono visibili nel menù laterale a destra.
</section>
<hr class="my-12 h-0.5 border-t-0 bg-neutral-100" />
<!-- Scene.js -->
<section>
    <h1 class="text-xl font-semibold text-gray-800">Scene.js</h1>
    <p>Il file <code>scene.js</code> è il cuore dell'applicazione: agisce da orchestratore inizializzando tutte le classi di cui ha
    bisogno si occupa del rendering della scena. Il suo costruttore è così formato:
    </p>
    <div class="flex flex-row gap-8 items-center">
        <img src="resources/images/code/scene.png" alt="Scene constructor" class="w-1/2 block ml-auto mr-auto py-2">
        <div class="">
                Il costruttore di Scene esegue le seguenti operazioni:
            <ul class="list-disc ml-8">
                <li>Inizializzazione contesto WebGL da canvas</li>
                <li>Inizializzazione WebGL Program a partire dagli shader</li>
                <li>Lettura del file di configurazione <strong>json</strong> per caricare gli elementi della scena</li>
            </ul>

        </div>
    </div>
</section>
<hr class="my-12 h-0.5 border-t-0 bg-neutral-100" />
<!-- Config.json -->
<section>
    <h1 class="text-xl font-semibold text-gray-800">File di configurazione JSON</h1>
    <p>Il file <code>scene.json</code> è lo scheletro di ogni scena: qui vengono settate le impostazioni iniziali della scena.
    </p>
    <div class="flex flex-row gap-8 items-center">
        <div class="">
            In questo file viene impostato:
            <ul class="list-disc ml-8">
                <li>Skybox</li>
                <li>Inizializzazione impostazioni camera - modificabili poi da menù</li>
                <li>Localizzato audio mp3 da caricare</li>
                <li>Inizializzazione impostazioni luce - modificabili poi da menù</li>
                <li>Caricamento modelli 3D Mesh - per ogni mesh viene specificato nome, path file <code>.obj</code> e path file <code>.mtl</code></li>
                <li>Inizializzazione Camera</li>
                <li>Inizializzazione Luci</li>
                <li>Inizializzazione Controller</li>
            </ul>

        </div>
        <img src="resources/images/code/json.png" alt="JSON Config" class="w-1/2 block ml-auto mr-auto py-2">
    </div>
</section>
<hr class="my-12 h-0.5 border-t-0 bg-neutral-100" />
<!-- Render.js -->
<section id="render" class="flex flex-col gap-2">
    <h1 class="text-xl font-semibold text-gray-800">Render.js</h1>
    <p>Il file <code>render.js</code> viene utilizzato per renderizzare l'intera scena. Per motivi di scope, questa funzione è stata messa all'esterno della classe <code>Scene</code>
    </p>
    <h3 class="text-lg font-semibold text-gray-800">Render base</h3>
    La scene disegnata con il rendering base ha queste caratteristiche:
    <ul class="list-disc ml-8">
    <li>supporto per texture e colori - grazie agli shaders</li>
    <li>luce diffusa</li>
    <li>specular lightning</li>
    </ul>
    <h3 class="text-lg font-semibold text-gray-800">Render avanzato</h3>
    <p>La tecnica di rendering avanzato che ho scelto per il mio progetto sono le ombre, realizzate con tecnica di shadow mapping.<br/>

        Per poter generare le ombre la scena viene disegnata due volta, prima dal punto di vista della luce per generare una shadowmap,
        poi dal punto di vista dell’osservatore utilizzando la shadowmap generata per capire se un punto è in ombra o meno.<br/>
        Per la realizzazione, è necessario attivare il culling, tramite il comando <code>gl.enable(gl.CULL_FACE)</code>. Per questo motivo le pareti della stanza diventano invisibili.
    </p>

    <div class="flex flex-row gap-8 items-center">
        <img src="resources/images/shadow-1.png" alt="Shadow First" class="w-1/2 block ml-auto mr-auto py-2">
        <img src="resources/images/shadow-2.png" alt="Shadow Second" class="w-1/2 block ml-auto mr-auto py-2">
    </div>
</section>
<hr class="my-12 h-0.5 border-t-0 bg-neutral-100" />
<!-- MeshObj.js -->
<section>
    <h1 class="text-xl font-semibold text-gray-800">File di configurazione JSON</h1>
    <p>Il file <code>scene.json</code> è lo scheletro di ogni scena: qui vengono settate le impostazioni iniziali della scena.
    </p>
    <div class="flex flex-row gap-8 items-center">
        <div class="">
            In questo file viene impostato:
            <ul class="list-disc ml-8">
                <li>Skybox</li>
                <li>Inizializzazione impostazioni camera - modificabili poi da menù</li>
                <li>Localizzato audio mp3 da caricare</li>
                <li>Inizializzazione impostazioni luce - modificabili poi da menù</li>
                <li>Caricamento modelli 3D Mesh - per ogni mesh viene specificato nome, path file <code>.obj</code> e path file <code>.mtl</code></li>
                <li>Inizializzazione Camera</li>
                <li>Inizializzazione Luci</li>
                <li>Inizializzazione Controller</li>
            </ul>

        </div>
        <img src="resources/images/code/json.png" alt="JSON Config" class="w-1/2 block ml-auto mr-auto py-2">
    </div>
</section>
<hr class="my-12 h-0.5 border-t-0 bg-neutral-100" />
<!-- Camera.js -->
<section>
    <h1 class="text-xl font-semibold text-gray-800">Camera.js</h1>
    Rappresenta la camera da cui viene osservata la scena.
    Il punto di vista può essere spostato all'interno dell'ambiente 3D in maniera libera.
    L'orientamento della camera viene definito (ma anche modificato) dai seguenti tre assi ortogonali espressi in coordinate globali:

    <div class="flex flex-col gap-2 p-4 rounded-md bg-gray-200">
        <span><b>position</b> posizione nello spazio della camera.</span>
        <span><b>forward</b> vettore che punta davanti la camera.</span>
        <span><b>right</b> vettore che punta alla destra della camera.</span>
        <span><b>up</b> vettore che punta verso l’alto.</span>
    </div>
    <h3 class="text-xl font-semibold text-gray-800 mt-4">Metodi</h3>
    Sono stati replicati i principali movimenti della produzione video.
        <img src="resources/images/camera_movements.webp" alt="Camera Movements" class="w-1/2 block ml-auto mr-auto py-2">

</section>

<h1 id="scene.js">scene.js</h1>
<p>
    Rappresenta la scena 3D e si occupa di orchestrare
    tutte le operazioni: dall'inizializzazione del canvas
    al rendering della scena stessa.
</p>
<p>
    All'istanziazione di un nuovo oggetto Scene, il metodo constructor
    esegue le seguenti operazioni:
<ul>
    <li>estrazione il contesto WebGL dal canvas</li>
    <li>impostazione delle dimensioni della viewport</li>
    <li>compilazione degli shader program</li>
    <li>lettura del file <strong>json</strong> contenente le mesh da mostrare</li>
    <li>per ogni mesh indicata nel file json viene istanziato un
        <strong>mesh_obj</strong> che viene salvato in una lista interna
        all'oggetto Scene</li>
    <li>inizializzazione della <strong>camera</strong>, binding dei metodi di
        input agli eventi: <strong>keys</strong> (tastiera), <strong>touch</strong>,
        <strong>mouse</strong> e <strong>light</strong> (oggetto luce di scena)</li>
</ul>
</p>
<p>
    Le mesh che verranno caricate e visalizzate sono indicate nel file json.
    Questa metodologia rende possibile creare più scene diverse semplicemente
    modificando i file json.
</p>
<p>
    Di seguito è riportata la struttura del file json:
</p>
<div class="sourceCode" id="cb1"><pre
        class="sourceCode json"><code class="sourceCode json"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>  <span class="er">&quot;meshes&quot;:</span><span class="ot">[</span></span>
        <span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">{</span></span>
        <span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;name&quot;</span><span class="fu">:</span><span class="st">&quot;mesh_1&quot;</span><span class="fu">,</span></span>
        <span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;obj_source&quot;</span><span class="fu">:</span><span class="st">&quot;./path/mesh.obj&quot;</span><span class="fu">,</span></span>
        <span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;mtl_source&quot;</span><span class="fu">:</span><span class="st">&quot;./path/mesh&quot;</span><span class="fu">,</span></span>
        <span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>      <span class="dt">&quot;position&quot;</span><span class="fu">:</span> <span class="ot">[</span><span class="dv">0</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">]</span></span>
        <span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">}</span></span>
        <span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="ot">]</span></span></code></pre></div>
<p>
    Ogni entry ha le seguenti proprietà:
<ul>
    <li><strong>name:</strong>
        nome della mesh, usato per il debug</li>
    <li><strong>obj_source:</strong>
        percorso del file .obj</li>
    <li><strong>mtl_source:</strong>
        percorso del file .mtl</li>
    <li><strong>position:</strong>
        posizione iniziale della mesh.</li>
</ul>
</p>
<p>
    Il valore dell'attributo <strong>position</strong>
    viene sommato alle coordinate della geometria
    della mesh, traslandolo nella posizione desiderata.
</p>

<h2 id="metodi">Metodi</h2>

<h3 id="async-loadMesh">async loadMesh( jsonPath )</h3>
<p>
    Si occupa di leggere il file json contenente le mesh da caricare e
    per ciascuno istanzia un oggetto mesh_obj che viene salvato in
    <code class="text-red-600 bg-gray-200 rounded-md p-1">scene.mesh_list</code>.
</p>

<h3 id="getProjectionMatrix">getProjectionMatrix()</h3>
<p>
    Si occupa di calcolare la projection matrix utilizzando la funzione
    <code class="text-red-600 bg-gray-200 rounded-md p-1">perspective(...)</code> della libreria m4.js.
</p>

<h3 id="keyController">keyController()</h3>
<p>
    Si occupa di intercettare gli input da tastiera e invoca le funzioni
    che modificano la posizione e la direzione della camera. <br>
    Questo metodo è realizzato in modo da poter gestire più input
    contemporanei e consentire, ad esempio, di muoversi e girare la
    camera nello stesso istante. <br>
    Viene invocata ogni qualvolta viene disegnato un frame.
</p>

<h3 id="async-prepareskybox">async prepareSkybox()</h3>
<p>
    Si occupa di caricare la cubemap texture utilizzata per lo skybox. <br>
    I dati vengono poi salvati in <code class="text-red-600 bg-gray-200 rounded-md p-1">scene.skybox</code>.
</p>

<h3 id="async-prepareshadow">async prepareShadow()</h3>
<p>
    Si occupa di preparare i dati per la gestione delle ombre,
    ovvero:
<ul>
    <li>compilazione degli shaders necessari</li>
    <li>creazione di una texture utilizzata come depth map</li>
    <li>impostazione dei valori utilizzati durante il rendering.</li>
</ul>
</p>

<h3 id="toggleShadows">toggleShadows()</h3>
<p>
    Si occupa gestire lo switch dallo shader program
    con ombre a quello senza e viceversa.
</p>

<h3 id="draw">draw()</h3>
<p>
    Per motivi di scope non è un metodo della classe
    Scene, ma una funzione a sé.<br>
    Si occupa di eseguire le seguenti operazioni:
<ul>
    <li>ridimensionare canvas e viewport in base alla grandezza della
        finestra</li>
    <li>chiamare il metodo <code class="text-red-600 bg-gray-200 rounded-md p-1">keyController()</code> per la
        gestione degli input da tastiera</li>
    <li>calcolare la projection e la view matrix</li>
    <li>la matrice di vista viene ottenuta da
        <code class="text-red-600 bg-gray-200 rounded-md p-1">scene.camera</code> che è un oggetto
        <code class="text-red-600 bg-gray-200 rounded-md p-1">Camera</code></li>
    <li>in base al valore di <code class="text-red-600 bg-gray-200 rounded-md p-1">scene.shadow.enable</code>:
        <ul>
            <li>viene eseguito il rendering con ombre</li>
            <li>viene eseguito il rendering senza ombre</li>
        </ul>
    </li>
</ul>
</p>
<p>
    Per il rendering è abilitato <code class="text-red-600 bg-gray-200 rounded-md p-1">gl.BLEND</code> quindi,
    se il materiale di una mesh ha opacità minore di uno,
    questo verrà disegnato con una trasparenza.
</p>

<p class="aligncenter">
    <img src="./resources/images/transparency.jpg" title="Oggetto con trasparenza" height="500"/>
</p>

<h3 id="rendering-base">Rendering base</h3>
<p>
    La scena disegnata con lo shader program di base ha
    le seguenti caratteristiche:
<ul>
    <li>supporto per texture e colori</li>
    <li>luce diffusa</li>
    <li>specular lightning</li>
</ul>
</p>

<p class="aligncenter">
    <img src="./resources/images/scene.jpg" title="Scena disegnata con rendering base" height="400"/>
</p>

<h3 id="rendering-con-ombre">Rendering con ombre</h3>
<p>
    La tecnica di rendering avanzata implementata nel progetto
    è il calcolo delle ombre, realizzata grazie alla tecnica
    dello shadow mapping.
</p>
<p>
    Per disegnare le ombre si disegna la scena dal punto di vista
    della luce, che applica l'algoritmo dello Shadow Buffer, il
    cui funzionamento è analogo a quello del Depth Buffer. <br>
    Il risultato di questo algoritmo è la Shadow Map, che descrive
    quali punti delle mesh sono illuminate e quali no. Questa
    mappa viene considerata insieme alla Depth Map generata dal
    punto di vista dell'osservatore e si determina quali punti
    sono da disegnare in ombra e quali no.
</p>

<p class="aligncenter">
    <img src="./resources/images/shadow_rendering.jpg" title="Scena disegnata con le ombre" height="400" />
</p>

<p><a href="#indice">Torna all’indice</a></p>
<hr />

<h1 id="camera.js">camera.js</h1>
<p>
    Rappresenta la camera da cui viene osservata la scena.<br>
    Il punto di vista può essere spostato all'interno
    dell'ambiente 3D in maniera libera.<br>
    L'orientamento della camera viene definito (ma anche
    modificato) dai seguenti tre assi ortogonali espressi
    in coordinate globali:
<ul>
    <li><strong>position:</strong> posizione nello spazio</li>
    <li><strong>forward:</strong> vettore che punta di fronte alla camera</li>
    <li><strong>right:</strong> vettore che punta alla destra della camera</li>
    <li><strong>up:</strong> View-up vector, punta verso l’alto</li>
</ul>
</p>

<h2 id="metodi-1">Metodi</h2>
<p>
    I movimenti della camera sono presi da quelli utilizzati nella
    produzione video.
</p>
<p class="aligncenter">
    <img src="./resources/images/camera_movements.jpg" title="Movimenti di camera" height="500" >
</p>
<h3 id="tiltstep">tilt( step )</h3>
<p>
    Ruota la visuale in alto o in basso, si ottiene ruotando
    la camera rispetto al vettore right.
</p>

<h3 id="panstep">pan( step )</h3>
<p>
    Ruota la visuale orizzontalmente, si ottiene ruotando
    la camera rispetto al View-up vector.
</p>

<h3 id="truckdist">truck( dist )</h3>
<p>
    Modifica la posizione della camera lateralmente, lasciando
    invariata la direzione della visuale. Si ottiene
    moltiplicando il vettore right per <code class="text-red-600 bg-gray-200 rounded-md p-1">dist</code> e
    sommando il risultato alla posizione attuale della camera.
</p>

<h3 id="pedestaldist">pedestal( dist )</h3>
<p>
    Alza o abbassa la posizione della camera, si ottiene sommando
    il prodotto tra il View-up vector e <code class="text-red-600 bg-gray-200 rounded-md p-1">dist</code> alla
    posizione attuale della camera.
</p>

<h3 id="dollystep">dolly( step )</h3>
<p>
    Avvicina o allontana la camera al punto osservato,
    si ottiene sommando alla posizione attuale il
    prodotto tra <code class="text-red-600 bg-gray-200 rounded-md p-1">dist</code> e il vettore forward.
</p>

<h3 id="realign">realign()</h3>
<p>
    Riallinea la vista della camera all'orizzonte.
</p>

<h3 id="getviewmatrix">getViewMatrix()</h3>
<p>
    Calcola e restituisce la viewMatrix. Il calcolo
    viene eseguito utilizzando i metodi della
    libreria m4.js.
</p>

<h3 id="getposition">getPosition()</h3>
<p>
    Restituisce la posizione della camera.
</p>

<p><a href="#indice">Torna all’indice</a></p>

<h1 id="mesh_obj.js">mesh_obj.js</h1>
<p>
    Questa classe si occupa di gestire le mesh visibili, dal
    loro caricamento fino al rendering.<br>
    Il costruttore prende le informazioni relative a una
    mesh contenute in una entry del file json, quali:
<ul>
    <li>percorso del file .obj</li>
    <li>percorso del file .mtl</li>
    <li>posizione della mesh rispetto all’origine</li>
</ul>
</p>
<p>
    Le mesh sono salvate nella cartella <code class="text-red-600 bg-gray-200 rounded-md p-1">project/data</code>,
    alcuni sono stati scaricati da internet, mentre altri sono
    stati disegnati su Blender.<br>
    Il formato utilizzato per l'utilizzo con WebGL è Wavefront obj,
    a cui è associato il file mtl che descrive le proprietà dei
    materiali che compongono le mesh.
</p>

<h2 id="metodi-2">Metodi</h2>

<h3 id="prepareMeshgl">prepareMesh( gl )</h3>
<p>
    Si occupa di creare i buffer per passare gli attribute al
    vertex shader, per fare ciò sfrutta la funzione
    <code class="text-red-600 bg-gray-200 rounded-md p-1">createBufferInfoFromArrays(gl, data)</code> della
    libreria webglUtils.js.
</p>

<h3 id="rendergl-programinfo-uniforms">render( gl, programInfo,
    uniforms )</h3>
<p>
    Si occupa di disegnare la mesh utilizzando lo shader
    program e gli uniform specificati nei parametri.<br>
    Tramite le funzioni della libreria webglUtils.js
    vengono passati attribute e uniform allo shader
    program. Utilizzando la funzione
    <code class="text-red-600 bg-gray-200 rounded-md p-1">webglUtils.drawBufferInfo(gl, bufferInfo)</code>
    viene invocata la <code class="text-red-600 bg-gray-200 rounded-md p-1">gl.drawElements</code> o la
    <code class="text-red-600 bg-gray-200 rounded-md p-1">gl.drawArrays</code> in base alla presenza degli
    indici o meno.
</p>

<p><a href="#indice">Torna all’indice</a></p>

<hr />

<h1 id="riferimenti">Riferimenti</h1>
<p>
    Per la realizzazione del progetto, oltre alle slide e al codice visto
    durante il corso, è stato fatto riferimento ai seguenti articoli:
<ul>
    <li>
        <a href="https://webglfundamentals.org/webgl/lessons/webgl-drawing-multiple-things.html">
            WebGL Fundamentals: Drawing Multiple Things</a>
    </li>
    <li>
        <a href="http://learnwebgl.brown37.net/07_cameras/camera_introduction.html">
            Learn WebGL: Introduction to camera</a>
    </li>
    <li>
        <a href="https://webglfundamentals.org/webgl/lessons/webgl-3d-camera.html">
            WebGL Fundamentals: 3D Camera</a>
    </li>
    <li>
        <a href="https://webglfundamentals.org/webgl/lessons/webgl-load-obj-w-mtl.html">
            WebGL Fundamentals: Loading .obj with Mtl</a>
    </li>
    <li>
        <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants">
            MDN web docs: WebGL constants</a>
    </li>
    <li>
        <a href="https://webglfundamentals.org/webgl/lessons/webgl-shadows.html">
            WebGL Fundamentals: Shadows</a>
    </li>
    <li>
        <a href="https://developer.mozilla.org/en-US/docs/Web/API/Touch_events/Multi-touch_interaction">
            MDN web docs: Multi-touch interaction</a>
    </li>
    <li>
        <a href="https://stackoverflow.com/questions/44456764/how-to-simulate-pinch-zoom-in-google-chrome">
            How to simulate pinch zoom in Google Chrome</a>
    </li>
</ul>
</p>

<p><a href="#indice">Torna all’indice</a></p>
<hr />

</body>
</html>